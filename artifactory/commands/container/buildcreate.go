package container

import (
	"strings"

	container "github.com/jfrog/jfrog-cli-artifactory/artifactory/commands/ocicontainer"
	"github.com/jfrog/jfrog-cli-core/v2/artifactory/utils"
	"github.com/jfrog/jfrog-cli-core/v2/common/build"
	"github.com/jfrog/jfrog-cli-core/v2/utils/config"
	"github.com/jfrog/jfrog-client-go/artifactory"
	"github.com/jfrog/jfrog-client-go/utils/errorutils"
	"github.com/jfrog/jfrog-client-go/utils/log"
)

type BuildDockerCreateCommand struct {
	ContainerCommandBase
	manifestSha256 string
}

func NewBuildDockerCreateCommand() *BuildDockerCreateCommand {
	return &BuildDockerCreateCommand{}
}

// Set tag and manifest sha256 of an image in Artifactory.
// This file can be generated by Kaniko using the '--image-name-with-digest-file' flag
// or by buildx CLI using '--metadata-file' flag.
// Tag and Sha256 will be used later on to search the image in Artifactory.
func (bdc *BuildDockerCreateCommand) SetImageNameWithDigest(filePath string) (err error) {
	bdc.image, bdc.manifestSha256, err = container.GetImageTagWithDigest(filePath)
	return
}

func (bdc *BuildDockerCreateCommand) Run() error {
	if err := bdc.init(); err != nil {
		return err
	}
	serverDetails, err := bdc.ServerDetails()
	if err != nil {
		return err
	}
	buildName, err := bdc.buildConfiguration.GetBuildName()
	if err != nil {
		return err
	}
	buildNumber, err := bdc.buildConfiguration.GetBuildNumber()
	if err != nil {
		return err
	}
	project := bdc.BuildConfiguration().GetProject()
	serviceManager, err := utils.CreateServiceManager(serverDetails, -1, 0, false)
	if err != nil {
		return err
	}
	if err = build.SaveBuildGeneralDetails(buildName, buildNumber, project); err != nil {
		return err
	}

	// Handle multiple tags from comma-separated image name
	images := SplitMultiTagDockerImageStringWithComma(bdc.image)
	if len(images) == 0 {
		return errorutils.CheckErrorf("no valid images found in image file")
	}

	// Get the repo argument (if provided) to use as fallback
	// The repo from each image takes precedence to handle cases where tags might be in different repositories
	fallbackRepo, _ := bdc.GetRepo()

	for _, image := range images {
		// Always try to get repo from the image first (takes precedence)
		repo, err := bdc.getRepoFromImage(image, serviceManager)
		if err != nil {
			// If getting repo from image fails, fall back to the CLI argument
			if fallbackRepo == "" {
				return errorutils.CheckErrorf("failed to get repository for image '%s': %s", image.Name(), err.Error())
			}
			repo = fallbackRepo
		} else {
			// Repository extracted from image name takes precedence over the mandatory CLI argument
			log.Debug("Repository extracted from image name '%s': '%s'. The mandatory repository CLI argument is not used.", image.Name(), repo)
		}

		builder, err := container.NewRemoteAgentBuildInfoBuilder(image, repo, buildName, buildNumber, project, serviceManager, bdc.manifestSha256)
		if err != nil {
			return errorutils.CheckErrorf("build info creation failed: %s", err.Error())
		}
		buildInfo, err := builder.Build(bdc.BuildConfiguration().GetModule())
		if err != nil {
			return errorutils.CheckErrorf("build info creation failed: %s", err.Error())
		}
		if err := build.SaveBuildInfo(buildName, buildNumber, project, buildInfo); err != nil {
			return errorutils.CheckErrorf("failed to save build info for '%s/%s': %s", buildName, buildNumber, err.Error())
		}
	}
	return nil
}

func (bdc *BuildDockerCreateCommand) CommandName() string {
	return "rt_build_docker_create"
}

func (bdc *BuildDockerCreateCommand) ServerDetails() (*config.ServerDetails, error) {
	return bdc.serverDetails, nil
}

// getRepoFromImage gets the repository name from a single image using the service manager
func (bdc *BuildDockerCreateCommand) getRepoFromImage(image *container.Image, serviceManager artifactory.ArtifactoryServicesManager) (string, error) {
	return image.GetRemoteRepo(serviceManager)
}

func SplitMultiTagDockerImageStringWithComma(image *container.Image) []*container.Image {
	multiDockerImage := image.Name()

	tags := strings.Split(multiDockerImage, ",")
	images := make([]*container.Image, 0, len(tags))
	for _, tag := range tags {
		trimmed := strings.TrimSpace(tag)
		if trimmed == "" {
			continue
		}
		nextImage := container.NewImage(trimmed)
		images = append(images, nextImage)
	}
	return images
}
